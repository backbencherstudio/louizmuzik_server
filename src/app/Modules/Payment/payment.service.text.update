/* eslint-disable @typescript-eslint/no-explicit-any */
import axios, { AxiosError } from 'axios';
import mongoose from 'mongoose';
import { User } from '../User/user.model';
import { generateAccessToken, PAYPAL_API } from '../../middleware/generateAccessTokenForPaypal';
import { sendPayoutToEmail } from '../../middleware/sendPayoutToEmail';
import { AppError } from '../../errors/AppErrors';
import { Transactions } from './payment.module';
import httpStatus from 'http-status';


const paypalSubscription = async (amount: number, userEmail: string) => {
  const accessToken = await generateAccessToken();

  try {
    const product = await axios.post(
      `${process.env.PAYPAL_API_BASE}/v1/catalogs/products`,
      {
        name: "Dynamic Subscription Product",
        type: "SERVICE",
        category: "SOFTWARE",
      },
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json",
        },
      }
    );

    const plan = await axios.post(
      `${process.env.PAYPAL_API_BASE}/v1/billing/plans`,
      {
        product_id: product.data.id,
        name: `Subscription for $${amount}`,
        billing_cycles: [
          {
            frequency: { interval_unit: "MONTH", interval_count: 1 },
            // frequency: { interval_unit: "DAY", interval_count: 1 },
            tenure_type: "REGULAR",
            sequence: 1,
            total_cycles: 0,
            pricing_scheme: {
              fixed_price: {
                value: amount.toString(),
                currency_code: "USD",
              },
            },
          },
        ],
        payment_preferences: {
          auto_bill_outstanding: true,
          payment_failure_threshold: 1,
        },
      },
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json",
        },
      }
    );

    const subscription = await axios.post(
      `${process.env.PAYPAL_API_BASE}/v1/billing/subscriptions`,
      {
        plan_id: plan.data.id,
        custom_id: userEmail,
        application_context: {
          brand_name: "melody",
          user_action: "SUBSCRIBE_NOW",
          return_url: "https://www.melodycollab.com/success",
          cancel_url: "https://www.melodycollab.com/cancel",
        },
      },
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json",
        },
      }
    );

    const approvalLink = subscription.data.links.find(
      (link: any) => link.rel === "approve"
    );

    if (!approvalLink) {
      throw new AppError(500, "Approval link not found");
    }

    return { url: approvalLink.href };

  } catch (error: any) {
    console.error("‚ùå Paypal Subscription Error:", error.response?.data || error.message);
    throw new AppError(500, error.response?.data?.message || error.message);
  }
};



const paypalSubscriptionCancel = async (subscriptionId: string) => {
  const accessToken = await generateAccessToken();

  console.log(103, subscriptionId);


  try {
    const subRes = await axios.get(
      `${process.env.PAYPAL_API_BASE}/v1/billing/subscriptions/${subscriptionId}`,
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      }
    );
    const planId = subRes.data.plan_id;
    // 2Ô∏è‚É£ Cancel the subscription
    await axios.post(
      `${process.env.PAYPAL_API_BASE}/v1/billing/subscriptions/${subscriptionId}/cancel`,
      {
        reason: "User manually cancelled the subscription",
      },
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json",
        },
      }
    );
    console.log("‚úÖ Subscription cancelled successfully:", subscriptionId);

    // 3Ô∏è‚É£ Deactivate the plan
    await axios.post(
      `${process.env.PAYPAL_API_BASE}/v1/billing/plans/${planId}/deactivate`,
      {},
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json",
        },
      }
    );
    console.log("üõë Plan deactivated successfully:", planId);

    const nextBillingTime = subRes.data.billing_info?.next_billing_time;
    console.log("üïí Raw nextBillingTime from webhook:", nextBillingTime);

    let endDate: Date | null = null;
    if (nextBillingTime && !isNaN(Date.parse(nextBillingTime))) {
      endDate = new Date(nextBillingTime);
    }

    await User.findOneAndUpdate(
      { paypalSubscriptionId: subscriptionId },
      {
        $set: {
          subscriptionEndDate: endDate,
        },
      },
      { new: true, runValidators: true }
    );

    return { success: true };
  } catch (error: any) {
    console.error("‚ùå Error cancelling subscription or deactivating plan:", error.response?.data || error.message);
    throw new Error(error.response?.data?.message || error.message);
  }
};

const createOrderWithPaypal = async (amount: any, selectedData: any) => {
  try {
    const accessToken = await generateAccessToken();
    const response = await axios.post(
      `${PAYPAL_API}/v2/checkout/orders`,
      {
        intent: "CAPTURE",
        purchase_units: [
          {
            amount: {
              currency_code: "USD",
              value: amount,
            },
            custom_id: JSON.stringify(selectedData),
          },
        ],
      },
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json",
        },
      }
    );

    return { id: response.data.id };
  } catch (err: any) {
    const statusCode = err?.response?.status || 500;
    // Extract possible PayPal error message
    const paypalError = err?.response?.data;
    const mainMessage = paypalError?.message || err.message || "Unknown PayPal error";
    const detailedDescription = paypalError?.details?.[0]?.description;

    const finalMessage = detailedDescription
      ? `${mainMessage}: ${detailedDescription}`
      : mainMessage;

    console.error("‚ùå PayPal Create Order Error:", paypalError);

    throw new AppError(statusCode, `PayPal Error - ${finalMessage}`);
  }
};

const captureOrder = async (orderID: string) => {
  try {
    const accessToken = await generateAccessToken();
    const response = await axios.post(
      `${PAYPAL_API}/v2/checkout/orders/${orderID}/capture`,
      {},
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          'Content-Type': 'application/json',
        },
      }
    );
    return response.data;
  } catch (err: any) {
    console.error("‚ùå Capture Order Error:", err?.response?.data || err.message);
    throw new AppError(500, err?.response?.data?.message || "Error capturing order");
  }
};



const webhookEvent = async (event: any, headers: any) => {
  try {
    const webhookId = process.env.PAYPAL_WEBHOOK_ID;
    const {
      'paypal-transmission-id': transmissionId,
      'paypal-transmission-time': timestamp,
      'paypal-transmission-sig': webhookSig,
      'paypal-cert-url': certUrl,
      'paypal-auth-algo': authAlgo,
    } = headers;

    const accessToken = await generateAccessToken();

    const verifyResponse = await axios.post(
      `${PAYPAL_API}/v1/notifications/verify-webhook-signature`,
      {
        transmission_id: transmissionId,
        transmission_time: timestamp,
        cert_url: certUrl,
        auth_algo: authAlgo,
        transmission_sig: webhookSig,
        webhook_id: webhookId,
        webhook_event: event,
      },
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          'Content-Type': 'application/json',
        },
      }
    );

    const isValid = verifyResponse.data.verification_status === 'SUCCESS';
    if (!isValid) {
      console.error('‚ùå Invalid webhook signature');
      throw new AppError(400, "Invalid webhook signature");
    }

    console.log("webhook hiiitt");

    // ================== when a user purses pack then call this  hook
    if (event.event_type === 'PAYMENT.CAPTURE.COMPLETED') {
      const resource = event.resource;
      const purchaseUnit = resource.purchase_units?.[0];
      const selectedDataRaw = purchaseUnit?.custom_id || resource?.custom_id;
      let selectedData: any[] = [];
      try {
        selectedData = JSON.parse(selectedDataRaw);
      } catch {
        console.warn("‚ö†Ô∏è Could not parse selectedData");
      }

      const producerIds = selectedData.map((item) =>
        new mongoose.Types.ObjectId(item.selectedProducerId)
      );

      const aggregationResult = await User.aggregate([
        {
          $match: {
            _id: { $in: producerIds },
          },
        },
        {
          $addFields: {
            totalPrice: {
              $reduce: {
                input: selectedData,
                initialValue: 0,
                in: {
                  $cond: [
                    { $eq: ['$$this.selectedProducerId', { $toString: '$_id' }] },
                    { $add: ['$$value', '$$this.price'] },
                    '$$value',
                  ],
                },
              },
            },
          },
        },
        {
          $project: {
            _id: 1,
            paypalEmail: 1,
            totalPrice: 1,
          },
        },
      ]);

      const payoutList = aggregationResult.map((producer) => {
        const gross = producer.totalPrice || 0;
        const paypalFee = parseFloat((gross * 0.029 + 0.3).toFixed(2)) * 2;
        const afterPaypal = gross - paypalFee;
        const serviceFee = parseFloat((afterPaypal * 0.03).toFixed(2));
        const payout = parseFloat((afterPaypal - serviceFee).toFixed(2));

        return {
          producerId: producer._id.toString(),
          paypalEmail: producer.paypalEmail,
          grossAmount: gross,
          paypalFee,
          platformFee: serviceFee,
          payoutAmount: payout,
        };
      });

      await Promise.all(
        payoutList.map(async (item) => {
          try {
            await sendPayoutToEmail(item.paypalEmail, item.payoutAmount);
            const user = await User.findById(item.producerId).select("email fullName _id producer_name");

            if (user) {
              const transaction = {
                userId: user._id,
                name: user.producer_name,
                email: user.email,
                salesAmount: item.payoutAmount,
                commission: item.platformFee,
              };
              await Transactions.create(transaction);
              console.log("‚úÖ Transaction recorded for:", user.email);
            } else {
              console.warn("‚ö†Ô∏è User not found for producerId:", item.producerId);
            }
          } catch (err: any) {
            console.error("‚ùå Payout or transaction failed:", err.message);
          }
        })
      );
    }

    // =================== this is subscription hook
    if (event.event_type === "BILLING.SUBSCRIPTION.ACTIVATED") {
      const subscriptionId = event.resource.id;
      const planId = event.resource.plan_id;
      const paypalEmail = event.resource.subscriber.email_address;
      const customEmail = event.resource.custom_id;
      const name = `${event.resource.subscriber.name.given_name} ${event.resource.subscriber.name.surname}`;
      const amount = event.resource.billing_info?.last_payment?.amount?.value;

      const subscribedUserData = await User.findOne({ email: customEmail });
      if (!subscribedUserData) throw new AppError(httpStatus.NOT_FOUND, 'User is not found');

      // const userData = await User.findOne({ paypalEmail }).select("paypalSubscriptionId")
      // after testing remove this line, ( this api and subscribedUserData this same)

      if (subscribedUserData?.paypalSubscriptionId) {
        const existingSubId = subscribedUserData?.paypalSubscriptionId;
        try {
          await axios.post(
            `${process.env.PAYPAL_API_BASE}/v1/billing/subscriptions/${existingSubId}/cancel`,
            { reason: "User upgraded or changed subscription." },
            {
              headers: {
                Authorization: `Bearer ${accessToken}`,
                "Content-Type": "application/json",
              },
            }
          );


          const subRes = await axios.get(
            `${process.env.PAYPAL_API_BASE}/v1/billing/subscriptions/${existingSubId}`,
            {
              headers: { Authorization: `Bearer ${accessToken}` },
            }
          );
          const planId = subRes.data.plan_id;

          // Deactivate Plan
          await axios.post(
            `${process.env.PAYPAL_API_BASE}/v1/billing/plans/${planId}/deactivate`,
            {},
            {
              headers: {
                Authorization: `Bearer ${accessToken}`,
                "Content-Type": "application/json",
              },
            }
          );

          console.log("‚úÖ Previous subscription canceled:", existingSubId);
        } catch (cancelErr: unknown) {
          const err = cancelErr as AxiosError;
          console.warn("‚ö†Ô∏è Failed to cancel previous subscription:", err.response?.data || err.message);
        }
      }

      await User.findOneAndUpdate(
        { email: subscribedUserData.email },
        {
          isPro: true,
          paypalSubscriptionId: subscriptionId,
          paypalPlanId: planId,
          subscribedAmount: amount,
        },
        { new: true, runValidators: true }
      )

      await User.findOneAndUpdate(
        { email: subscribedUserData.email },
        { $unset: { subscriptionEndDate: "" } },
        { new: true, runValidators: true }
      );


      const transaction = {
        email: subscribedUserData.email,
        name: subscribedUserData.producer_name,
        userId: subscribedUserData._id,
        subscriptionAmount: parseInt(amount),
        salesAmount: 0,
        commission: 0,
      };
      await Transactions.create(transaction);
    }

    

    // ===================== auto pay data store 
    if (event.event_type === "PAYMENT.SALE.COMPLETED") {
      const amount = event.resource.amount?.total;
      const billingAgreementId = event.resource.billing_agreement_id;

      const user = await User.findOne({ paypalSubscriptionId: billingAgreementId });

      if (!user) {
        console.warn("‚ö†Ô∏è No user found for recurring subscription:", billingAgreementId);
        return;
      }

      const transaction = {
        email: user.email,
        name: user.producer_name,
        userId: user._id,
        subscriptionAmount: parseInt(amount),
        salesAmount: 0,
        commission: 0,
      };

      await Transactions.create(transaction);
      console.log("‚úÖ Monthly subscription payment logged for:", user.email);
    }

    if (event.event_type === "BILLING.SUBSCRIPTION.CANCELLED") {
      const subscriptionId = event.resource.id;
      await User.findOneAndUpdate({ paypalSubscriptionId: subscriptionId }, {
        isPro: false,
        paypalSubscriptionId: null,
        paypalPlanId: null,
        subscribedAmount: 0,
      });
      console.log("‚ùå Subscription & Plan cancelled:", subscriptionId);
    }

    // =================== subscription canseled or ( amount not available then subscription auto cansel )
    if (event.event_type === "BILLING.SUBSCRIPTION.SUSPENDED") {
      const subscriptionId = event.resource.id;

      console.log("üö´ Subscription Suspended (likely due to failed payment):", subscriptionId);

      const user = await User.findOne({ paypalSubscriptionId: subscriptionId });

      if (user) {
        await User.findByIdAndUpdate(user._id, {
          isPro: false,
          paypalSubscriptionId: null,
          paypalPlanId: null,
          subscribedAmount: 0,
        });

        try {
          await axios.post(
            `${process.env.PAYPAL_API_BASE}/v1/billing/subscriptions/${subscriptionId}/cancel`,
            { reason: "Payment failed multiple times" },
            {
              headers: {
                Authorization: `Bearer ${accessToken}`,
                "Content-Type": "application/json",
              },
            }
          );
          console.log("‚úÖ Suspended subscription canceled :", subscriptionId);
        } catch (err: any) {
          console.error("‚ùå Failed to cancel suspended subscription:", err.response?.data || err.message);
        }

        const subRes = await axios.get(
          `${process.env.PAYPAL_API_BASE}/v1/billing/subscriptions/${subscriptionId}`,
          {
            headers: { Authorization: `Bearer ${accessToken}` },
          }
        );
        const planId = subRes.data.plan_id;

        // Deactivate Plan
        await axios.post(
          `${process.env.PAYPAL_API_BASE}/v1/billing/plans/${planId}/deactivate`,
          {},
          {
            headers: {
              Authorization: `Bearer ${accessToken}`,
              "Content-Type": "application/json",
            },
          }
        );

        console.log("üìâ User downgraded due to payment failure:", user.email);
      } else {
        console.warn("‚ö†Ô∏è No user found for suspended subscription:", subscriptionId);
      }
    }


    if (event.event_type === "PAYMENT.SALE.DENIED") {
      const payment = event.resource;
      const amount = payment.amount?.value;
      const userEmail = event.resource.custom_id; // if you passed it during creation

      console.warn("üö´ Payment Denied for:", userEmail, "Amount:", amount);

      const user = await User.findOne({ email: userEmail });
      if (user) {

        await User.findByIdAndUpdate(user._id, {
          isPro: false,
          paypalSubscriptionId: null,
          paypalPlanId: null,
          subscribedAmount: 0,
        });

        // Optional: cancel subscription too
        if (user.paypalSubscriptionId) {
          const subscriptionId = user.paypalSubscriptionId
          try {
            await axios.post(
              `${process.env.PAYPAL_API_BASE}/v1/billing/subscriptions/${subscriptionId}/cancel`,
              { reason: "Payment failed multiple times" },
              {
                headers: {
                  Authorization: `Bearer ${accessToken}`,
                  "Content-Type": "application/json",
                },
              }
            );
            console.log("‚úÖ Suspended subscription canceled :", subscriptionId);
          } catch (err: any) {
            console.error("‚ùå Failed to cancel suspended subscription:", err.response?.data || err.message);
          }

          const subRes = await axios.get(
            `${process.env.PAYPAL_API_BASE}/v1/billing/subscriptions/${subscriptionId}`,
            {
              headers: { Authorization: `Bearer ${accessToken}` },
            }
          );
          const planId = subRes.data.plan_id;

          // Deactivate Plan
          await axios.post(
            `${process.env.PAYPAL_API_BASE}/v1/billing/plans/${planId}/deactivate`,
            {},
            {
              headers: {
                Authorization: `Bearer ${accessToken}`,
                "Content-Type": "application/json",
              },
            }
          );
        }

      }

      // Optionally: Send email alert to the user
    }

    return 200;
  } catch (err: any) {
    console.error('‚ùå Webhook Handling Error:', err?.response?.data || err.message);
    return 500;
  }
};


export const paymentService = {
  paypalSubscription,
  paypalSubscriptionCancel,
  createOrderWithPaypal,
  captureOrder,
  webhookEvent
};
